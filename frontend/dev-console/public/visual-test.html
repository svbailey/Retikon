<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Retikon Visual Test</title>
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
    />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;600&family=Space+Grotesk:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="visual-core.css"
    />
  </head>
  <body>
    <main class="shell">
      <header>
        <span class="pill accent">visual test</span>
        <h1>Retikon staging visual run</h1>
        <p class="subtitle">
          Upload a document, watch ingestion progress, preview model outputs,
          then run a simple query. Keep this page open during the run.
        </p>
      </header>

      <section class="grid">
        <div class="panel">
          <div class="panel-header">
            <h2>Configuration</h2>
          </div>
          <div class="field">
            <label>JWT / AI token</label>
            <input id="jwt" type="password" placeholder="Paste JWT" />
          </div>
          <div class="field">
            <label>Dev API URL</label>
            <input
              id="devApi"
              type="url"
              placeholder="https://retikon-dev-console-...run.app"
            />
          </div>
          <div class="field">
            <label>Query URL</label>
            <input
              id="queryUrl"
              type="url"
              placeholder="https://retikon-query-...run.app/query"
            />
          </div>
          <div class="inline">
            <button id="saveConfig" class="secondary">Save</button>
            <button id="resetConfig" class="ghost">Clear</button>
          </div>
          <p class="notice">
            Values are saved locally in your browser. JWT must include required
            claims (org_id at minimum).
          </p>
        </div>

        <div class="panel">
          <div class="panel-header">
            <h2>Run state</h2>
          </div>
          <div class="steps">
            <div class="step-card" data-step="upload" data-state="idle">
              <div class="step-title">1. Upload</div>
              <div class="step-status">idle</div>
              <div class="step-detail">Awaiting file</div>
            </div>
            <div class="step-card" data-step="ingest" data-state="idle">
              <div class="step-title">2. Ingest</div>
              <div class="step-status">idle</div>
              <div class="step-detail">No status yet</div>
            </div>
            <div class="step-card" data-step="manifest" data-state="idle">
              <div class="step-title">3. Manifest</div>
              <div class="step-status">idle</div>
              <div class="step-detail">Manifest not loaded</div>
            </div>
            <div class="step-card" data-step="index" data-state="idle">
              <div class="step-title">4. Index + Reload</div>
              <div class="step-status">idle</div>
              <div class="step-detail">Not triggered</div>
            </div>
            <div class="step-card" data-step="query" data-state="idle">
              <div class="step-title">5. Query</div>
              <div class="step-status">idle</div>
              <div class="step-detail">No query yet</div>
            </div>
          </div>
        </div>
      </section>

      <section class="grid">
        <div class="panel">
          <div class="panel-header">
            <h2>Upload + ingest</h2>
          </div>
          <div class="field">
            <label>File</label>
            <input id="fileInput" type="file" />
          </div>
          <div class="field">
            <label>Category</label>
            <select id="category">
              <option value="docs">docs</option>
              <option value="images">images</option>
              <option value="audio">audio</option>
              <option value="videos">video</option>
            </select>
          </div>
          <div class="actions">
            <button id="uploadBtn">Upload</button>
            <button id="pollBtn" class="secondary">Poll ingest</button>
            <button id="runAllBtn" class="ghost">Run end-to-end</button>
          </div>
          <div class="notice" id="uploadInfo">No upload yet.</div>
        </div>

        <div class="panel">
          <div class="panel-header">
            <h2>Activity</h2>
          </div>
          <div class="log" id="activityLog"></div>
        </div>
      </section>

      <section class="grid">
        <div class="panel">
          <div class="panel-header">
            <h2>Manifest + model outputs</h2>
          </div>
          <div class="field">
            <label>Manifest URI (optional override)</label>
            <input
              id="manifestUri"
              type="text"
              placeholder="gs://.../manifests/<run-id>/manifest.json"
            />
          </div>
          <div class="actions">
            <button id="manifestBtn">Load manifest</button>
          </div>
          <div class="preview-list" id="manifestList"></div>
        </div>

        <div class="panel">
          <div class="panel-header">
            <h2>Preview</h2>
          </div>
          <div id="previewMeta" class="notice">
            Preview a manifest file to see sample rows.
          </div>
          <div id="previewTable" class="data-block"></div>
        </div>
      </section>

      <section class="grid">
        <div class="panel">
          <div class="panel-header">
            <h2>Index + snapshot</h2>
          </div>
          <div class="actions">
            <button id="indexBtn" class="secondary">Trigger index</button>
            <button id="indexStatusBtn" class="ghost">Index status</button>
            <button id="reloadBtn">Reload snapshot</button>
          </div>
          <div class="notice" id="indexInfo">No index action yet.</div>
        </div>

        <div class="panel">
          <div class="panel-header">
            <h2>Query</h2>
          </div>
          <div class="field">
            <label>Query text</label>
            <input id="queryText" type="text" value="Retikon demo query" />
          </div>
          <div class="field">
            <label>Top K</label>
            <input id="topK" type="number" min="1" max="50" value="5" />
          </div>
          <div class="actions">
            <button id="queryBtn">Run query</button>
          </div>
          <div class="data-block" id="queryResults">No query yet.</div>
        </div>
      </section>

      <section class="panel story-panel hidden" id="storyPanel">
        <div class="panel-header">
          <h2>Video Story</h2>
          <span class="pill accent">post-ingest</span>
        </div>
        <p class="notice" id="storyStatus">
          Upload a video and complete ingestion to reveal a human-friendly
          summary of what the system learned.
        </p>

        <div class="story-grid">
          <div class="story-video">
            <div class="story-header">
              <div>
                <h3>Your video</h3>
                <p class="notice">Playback plus the facts extracted into the graph.</p>
              </div>
              <button id="storyRefresh" class="secondary">Refresh story</button>
            </div>
            <video id="storyVideo" controls></video>
            <div class="story-meta" id="storyVideoMeta">Video preview not loaded.</div>
            <div class="story-meta">
              <div><strong>Source</strong> <span id="storySourceUri">-</span></div>
              <div><strong>Manifest</strong> <span id="storyManifestUri">-</span></div>
            </div>
          </div>

          <div class="story-facts" id="storyFacts">
            <div class="fact-card">
              <span class="fact-label">Duration</span>
              <span class="fact-value" id="storyDuration">-</span>
            </div>
            <div class="fact-card">
              <span class="fact-label">Resolution</span>
              <span class="fact-value" id="storyResolution">-</span>
            </div>
            <div class="fact-card">
              <span class="fact-label">Frames</span>
              <span class="fact-value" id="storyFrames">-</span>
            </div>
            <div class="fact-card">
              <span class="fact-label">Audio</span>
              <span class="fact-value" id="storyAudio">-</span>
            </div>
            <div class="fact-card">
              <span class="fact-label">File size</span>
              <span class="fact-value" id="storySize">-</span>
            </div>
            <div class="fact-card">
              <span class="fact-label">Transcript</span>
              <span class="fact-value" id="storyTranscriptCount">-</span>
            </div>
            <div class="fact-card">
              <span class="fact-label">Keyframes</span>
              <span class="fact-value" id="storyKeyframeCount">-</span>
            </div>
            <div class="fact-card">
              <span class="fact-label">Relations</span>
              <span class="fact-value" id="storyRelationCount">-</span>
            </div>
          </div>
        </div>

        <div class="story-tabs">
          <button class="story-tab active" data-story-tab="highlights">
            Highlights
          </button>
          <button class="story-tab" data-story-tab="transcript">Transcript</button>
          <button class="story-tab" data-story-tab="labels">Visual Labels</button>
          <button class="story-tab" data-story-tab="keyframes">Keyframes</button>
        </div>

        <div class="story-tab-content active" data-story-content="highlights">
          <div class="story-summary" id="storySummary"></div>
        </div>
        <div class="story-tab-content" data-story-content="transcript">
          <div class="data-block" id="storyTranscript">
            Transcript will appear here after ingest completes.
          </div>
        </div>
        <div class="story-tab-content" data-story-content="labels">
          <div class="label-section">
            <h4>Objects</h4>
            <div class="label-chip-group" id="storyLabelObjects">
              Labels will appear after ingest completes.
            </div>
          </div>
          <div class="label-section" style="margin-top: 12px;">
            <h4>Scenes</h4>
            <div class="label-chip-group" id="storyLabelScenes"></div>
          </div>
          <div class="label-section" style="margin-top: 12px;">
            <h4>Actions</h4>
            <div class="label-chip-group" id="storyLabelActions"></div>
          </div>
          <div class="label-meta" id="storyLabelMeta"></div>
        </div>
        <div class="story-tab-content" data-story-content="keyframes">
          <div class="keyframe-grid" id="storyKeyframes"></div>
        </div>
      </section>
    </main>

    <script>
      const state = {
        upload: null,
        ingest: null,
        manifest: null,
        preview: null,
        story: {
          loaded: false,
          loading: false,
          thumbs: {},
        },
      };

      const els = {
        jwt: document.getElementById("jwt"),
        devApi: document.getElementById("devApi"),
        queryUrl: document.getElementById("queryUrl"),
        saveConfig: document.getElementById("saveConfig"),
        resetConfig: document.getElementById("resetConfig"),
        fileInput: document.getElementById("fileInput"),
        category: document.getElementById("category"),
        uploadBtn: document.getElementById("uploadBtn"),
        pollBtn: document.getElementById("pollBtn"),
        runAllBtn: document.getElementById("runAllBtn"),
        uploadInfo: document.getElementById("uploadInfo"),
        activityLog: document.getElementById("activityLog"),
        manifestUri: document.getElementById("manifestUri"),
        manifestBtn: document.getElementById("manifestBtn"),
        manifestList: document.getElementById("manifestList"),
        previewMeta: document.getElementById("previewMeta"),
        previewTable: document.getElementById("previewTable"),
        indexBtn: document.getElementById("indexBtn"),
        indexStatusBtn: document.getElementById("indexStatusBtn"),
        reloadBtn: document.getElementById("reloadBtn"),
        indexInfo: document.getElementById("indexInfo"),
        queryText: document.getElementById("queryText"),
        topK: document.getElementById("topK"),
        queryBtn: document.getElementById("queryBtn"),
        queryResults: document.getElementById("queryResults"),
        storyPanel: document.getElementById("storyPanel"),
        storyStatus: document.getElementById("storyStatus"),
        storyRefresh: document.getElementById("storyRefresh"),
        storyVideo: document.getElementById("storyVideo"),
        storyVideoMeta: document.getElementById("storyVideoMeta"),
        storySourceUri: document.getElementById("storySourceUri"),
        storyManifestUri: document.getElementById("storyManifestUri"),
        storyDuration: document.getElementById("storyDuration"),
        storyResolution: document.getElementById("storyResolution"),
        storyFrames: document.getElementById("storyFrames"),
        storyAudio: document.getElementById("storyAudio"),
        storySize: document.getElementById("storySize"),
        storyTranscriptCount: document.getElementById("storyTranscriptCount"),
        storyKeyframeCount: document.getElementById("storyKeyframeCount"),
        storyRelationCount: document.getElementById("storyRelationCount"),
        storySummary: document.getElementById("storySummary"),
        storyTranscript: document.getElementById("storyTranscript"),
        storyLabelObjects: document.getElementById("storyLabelObjects"),
        storyLabelScenes: document.getElementById("storyLabelScenes"),
        storyLabelActions: document.getElementById("storyLabelActions"),
        storyLabelMeta: document.getElementById("storyLabelMeta"),
        storyKeyframes: document.getElementById("storyKeyframes"),
        storyTabs: Array.from(document.querySelectorAll("[data-story-tab]")),
        storyContents: Array.from(
          document.querySelectorAll("[data-story-content]"),
        ),
      };

      const STORAGE_KEY = "retikon_visual_test_config";

      const setStep = (step, stateLabel, detail) => {
        const card = document.querySelector(`[data-step="${step}"]`);
        if (!card) return;
        card.dataset.state = stateLabel;
        card.querySelector(".step-status").textContent = stateLabel;
        if (detail) {
          card.querySelector(".step-detail").textContent = detail;
        }
      };

      const addLog = (message, tone = "info") => {
        const item = document.createElement("div");
        item.className = `log-item ${tone}`;
        item.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
        els.activityLog.prepend(item);
      };

      const getConfig = () => ({
        jwt: els.jwt.value.replace(/\s+/g, ""),
        devApi: els.devApi.value.trim().replace(/\/$/, ""),
        queryUrl: els.queryUrl.value.trim(),
      });

      const authHeaders = () => {
        const { jwt } = getConfig();
        return jwt ? { Authorization: `Bearer ${jwt}` } : {};
      };

      const saveConfig = () => {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(getConfig()));
        addLog("Configuration saved.", "success");
      };

      const loadConfig = () => {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        try {
          const cfg = JSON.parse(raw);
          els.jwt.value = cfg.jwt || "";
          els.devApi.value = cfg.devApi || "";
          els.queryUrl.value = cfg.queryUrl || "";
        } catch (err) {
          addLog("Failed to load saved config.", "error");
        }
      };

      const clearConfig = () => {
        localStorage.removeItem(STORAGE_KEY);
        els.jwt.value = "";
        els.devApi.value = "";
        els.queryUrl.value = "";
        addLog("Configuration cleared.", "info");
      };

      const apiFetch = async (url, options = {}) => {
        const resp = await fetch(url, {
          ...options,
          headers: {
            ...(options.headers || {}),
            ...authHeaders(),
          },
        });
        if (!resp.ok) {
          const text = await resp.text();
          throw new Error(text || `Request failed (${resp.status})`);
        }
        return resp.json();
      };

      const formatBytes = (value) => {
        if (!value && value !== 0) return "-";
        const units = ["B", "KB", "MB", "GB"];
        let size = Number(value);
        let unit = 0;
        while (size >= 1024 && unit < units.length - 1) {
          size /= 1024;
          unit += 1;
        }
        return `${size.toFixed(size >= 10 || unit === 0 ? 0 : 1)} ${units[unit]}`;
      };

      const formatDuration = (ms) => {
        if (!ms && ms !== 0) return "-";
        const totalSeconds = Math.floor(Number(ms) / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}:${String(seconds).padStart(2, "0")}`;
      };

      const formatTimestamp = (ms) => {
        if (!ms && ms !== 0) return "-";
        return formatDuration(ms);
      };

      const setStoryValue = (el, value) => {
        if (!el) return;
        el.textContent = value ?? "-";
      };

      const showStoryPanel = () => {
        els.storyPanel?.classList.remove("hidden");
      };

      const activateStoryTab = (name) => {
        els.storyTabs.forEach((tab) => {
          tab.classList.toggle("active", tab.dataset.storyTab === name);
        });
        els.storyContents.forEach((content) => {
          content.classList.toggle(
            "active",
            content.dataset.storyContent === name,
          );
        });
      };

      const fetchBinary = async (url) => {
        const resp = await fetch(url, { headers: authHeaders() });
        if (!resp.ok) {
          const text = await resp.text();
          throw new Error(text || `Request failed (${resp.status})`);
        }
        return resp.blob();
      };

      const fetchRawObject = async (uri) => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        const target = `${devApi}/dev/object?uri=${encodeURIComponent(uri)}`;
        return fetchBinary(target);
      };

      const fetchGraphObject = async (uri) => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        const target = `${devApi}/dev/graph-object?uri=${encodeURIComponent(uri)}`;
        return fetchBinary(target);
      };

      const fetchVisualLabels = async (mediaAssetId) => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        const target =
          `${devApi}/dev/visual-labels?media_asset_id=${encodeURIComponent(
            mediaAssetId,
          )}&top_k=8&max_frames=12`;
        return apiFetch(target);
      };

      const renderLabelChips = (el, items) => {
        if (!el) return;
        el.innerHTML = "";
        if (!items?.length) {
          el.textContent = "No labels available.";
          return;
        }
        items.forEach((item) => {
          const chip = document.createElement("div");
          chip.className = "label-chip";
          const label = document.createElement("strong");
          label.textContent = item.label;
          const score = document.createElement("span");
          score.textContent = `${Math.round((item.score || 0) * 100)}%`;
          chip.append(label, score);
          el.append(chip);
        });
      };

      const uploadFile = async () => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        const file = els.fileInput.files[0];
        if (!file) {
          throw new Error("Choose a file before uploading.");
        }
        setStep("upload", "working", "Uploading file...");
        addLog("Uploading file to raw bucket...", "info");
        const form = new FormData();
        form.append("file", file);
        form.append("category", els.category.value);
        const resp = await fetch(`${devApi}/dev/upload`, {
          method: "POST",
          headers: authHeaders(),
          body: form,
        });
        if (!resp.ok) {
          const text = await resp.text();
          throw new Error(text || "Upload failed");
        }
        const data = await resp.json();
        state.upload = data;
        state.story.loaded = false;
        state.story.loading = false;
        state.story.thumbs = {};
        if (els.storyPanel) {
          els.storyPanel.classList.add("hidden");
        }
        if (els.storyVideo) {
          els.storyVideo.removeAttribute("src");
        }
        if (els.storyVideoMeta) {
          els.storyVideoMeta.textContent = "Video preview not loaded.";
        }
        if (els.storyLabelObjects) {
          els.storyLabelObjects.textContent =
            "Labels will appear after ingest completes.";
        }
        if (els.storyLabelScenes) {
          els.storyLabelScenes.textContent = "";
        }
        if (els.storyLabelActions) {
          els.storyLabelActions.textContent = "";
        }
        if (els.storyLabelMeta) {
          els.storyLabelMeta.textContent = "";
        }
        els.uploadInfo.textContent = `Uploaded ${data.name} (${data.size_bytes} bytes)`;
        setStep("upload", "done", `URI: ${data.uri}`);
        addLog("Upload complete.", "success");
        return data;
      };

      const isVideoUpload = () =>
        Boolean(state.upload?.name && state.upload.name.includes("/videos/"));

      const loadVideoStory = async () => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        if (!isVideoUpload()) {
          els.storyStatus.textContent =
            "Video story is only available for video uploads.";
          return;
        }
        const manifestUri = state.ingest?.firestore?.manifest_uri;
        if (!manifestUri) {
          els.storyStatus.textContent =
            "Waiting for manifest data from ingestion.";
          return;
        }
        if (state.story.loading) {
          return;
        }
        state.story.loading = true;
        showStoryPanel();
        els.storyStatus.textContent = "Building your video story...";

        try {
          const manifest = await apiFetch(
            `${devApi}/dev/manifest?manifest_uri_value=${encodeURIComponent(
              manifestUri
            )}`
          );
          const files = manifest.files || [];
          const counts = manifest.counts || state.ingest?.firestore?.counts || {};
          const findFile = (needle) =>
            files.find((file) =>
              String(file.uri || file.path || "").includes(needle)
            );
          const mediaFile = findFile("/vertices/MediaAsset/core/");
          const imageFile = findFile("/vertices/ImageAsset/core/");
          const transcriptFile = findFile("/vertices/Transcript/text/");
          const mediaPreview = mediaFile?.uri
            ? await apiFetch(
                `${devApi}/dev/parquet-preview?path=${encodeURIComponent(
                  mediaFile.uri
                )}&limit=5`
              )
            : null;
          const imagePreview = imageFile?.uri
            ? await apiFetch(
                `${devApi}/dev/parquet-preview?path=${encodeURIComponent(
                  imageFile.uri
                )}&limit=20`
              )
            : null;
          const transcriptPreview = transcriptFile?.uri
            ? await apiFetch(
                `${devApi}/dev/parquet-preview?path=${encodeURIComponent(
                  transcriptFile.uri
                )}&limit=6`
              )
            : null;

          const mediaTargetId = state.ingest?.firestore?.media_asset_id;
          const mediaRow =
            mediaPreview?.rows?.find((row) => row.id === mediaTargetId) ||
            mediaPreview?.rows?.[0] ||
            null;
          const imageRows = (imagePreview?.rows || []).filter((row) =>
            mediaTargetId ? row.media_asset_id === mediaTargetId : true
          );
          const transcriptRows = transcriptPreview?.rows || [];

          setStoryValue(els.storyDuration, formatDuration(mediaRow?.duration_ms));
          setStoryValue(
            els.storyResolution,
            mediaRow?.width_px && mediaRow?.height_px
              ? `${mediaRow.width_px} x ${mediaRow.height_px}`
              : "-"
          );
          setStoryValue(
            els.storyFrames,
            mediaRow?.frame_count ?? counts.ImageAsset ?? "-"
          );
          setStoryValue(
            els.storyAudio,
            (counts.AudioClip || 0) > 0 ? "Yes" : "No"
          );
          setStoryValue(els.storySize, formatBytes(mediaRow?.size_bytes));
          setStoryValue(
            els.storyTranscriptCount,
            counts.Transcript ?? transcriptRows.length ?? "-"
          );
          setStoryValue(
            els.storyKeyframeCount,
            counts.ImageAsset ?? imageRows.length ?? "-"
          );
          setStoryValue(els.storyRelationCount, counts.DerivedFrom ?? "-");
          setStoryValue(els.storySourceUri, mediaRow?.uri || state.upload?.uri);
          setStoryValue(els.storyManifestUri, manifest.manifest_uri || manifestUri);

          if (state.story.videoUrl) {
            URL.revokeObjectURL(state.story.videoUrl);
            state.story.videoUrl = null;
          }
          if (mediaRow?.uri || state.upload?.uri) {
            try {
              const blob = await fetchRawObject(mediaRow?.uri || state.upload?.uri);
              const objectUrl = URL.createObjectURL(blob);
              state.story.videoUrl = objectUrl;
              els.storyVideo.src = objectUrl;
              els.storyVideoMeta.textContent = "Video preview ready.";
            } catch (err) {
              els.storyVideoMeta.textContent = `Video preview unavailable: ${
                err.message || err
              }`;
            }
          }

          const summaryItems = [];
          if (mediaRow?.duration_ms) {
            summaryItems.push(
              `This video is ${formatDuration(
                mediaRow.duration_ms
              )} long at ${mediaRow.width_px} x ${mediaRow.height_px}.`
            );
          }
          if (counts.ImageAsset) {
            summaryItems.push(
              `We captured ${counts.ImageAsset} keyframes to represent the visuals.`
            );
          }
          if (counts.Transcript) {
            summaryItems.push(
              `We generated ${counts.Transcript} transcript segments from the audio.`
            );
          }
          if (counts.DerivedFrom) {
            summaryItems.push(
              `${counts.DerivedFrom} relationships link frames, transcript, and the source asset.`
            );
          }
          els.storySummary.innerHTML = "";
          if (summaryItems.length === 0) {
            els.storySummary.textContent = "No summary yet.";
          } else {
            summaryItems.forEach((text) => {
              const item = document.createElement("div");
              item.className = "summary-item";
              item.textContent = text;
              els.storySummary.append(item);
            });
          }

          const transcriptText = transcriptRows
            .map((row) => row.content)
            .filter(Boolean);
          els.storyTranscript.textContent = transcriptText.length
            ? transcriptText.map((line) => `â€¢ ${line}`).join("\n")
            : "No transcript segments were recorded.";

          els.storyKeyframes.innerHTML = "";
          if (!imageRows.length) {
            els.storyKeyframes.textContent = "No keyframes found.";
          } else {
            for (const row of imageRows.slice(0, 12)) {
              const card = document.createElement("div");
              card.className = "keyframe-card";
              const img = document.createElement("img");
              img.alt = `Keyframe at ${formatTimestamp(row.timestamp_ms)}`;
              const time = document.createElement("div");
              time.className = "keyframe-time";
              time.textContent = formatTimestamp(row.timestamp_ms);
              card.append(img, time);
              els.storyKeyframes.append(card);
              if (row.thumbnail_uri) {
                try {
                  if (!state.story.thumbs[row.thumbnail_uri]) {
                    const blob = await fetchGraphObject(row.thumbnail_uri);
                    state.story.thumbs[row.thumbnail_uri] =
                      URL.createObjectURL(blob);
                  }
                  img.src = state.story.thumbs[row.thumbnail_uri];
                } catch (err) {
                  img.alt = "Thumbnail unavailable.";
                }
              }
            }
          }

          if (mediaTargetId) {
            try {
              const labelData = await fetchVisualLabels(mediaTargetId);
              renderLabelChips(
                els.storyLabelObjects,
                labelData.labels?.object || [],
              );
              renderLabelChips(
                els.storyLabelScenes,
                labelData.labels?.scene || [],
              );
              renderLabelChips(
                els.storyLabelActions,
                labelData.labels?.action || [],
              );
              if (els.storyLabelMeta) {
                els.storyLabelMeta.textContent = `Model backend: ${labelData.backend} | Frames scored: ${labelData.frame_count}`;
              }
            } catch (err) {
              if (els.storyLabelMeta) {
                els.storyLabelMeta.textContent = `Labels unavailable: ${
                  err.message || err
                }`;
              }
            }
          }

          els.storyStatus.textContent =
            "Video story ready. Explore transcript and keyframes below.";
          state.story.loaded = true;
          activateStoryTab("highlights");
        } finally {
          state.story.loading = false;
        }
      };

      const fetchIngestStatus = async () => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        if (!state.upload?.uri) {
          throw new Error("Upload a file first.");
        }
        const uri = encodeURIComponent(state.upload.uri);
        const data = await apiFetch(`${devApi}/dev/ingest-status?uri=${uri}`);
        state.ingest = data;
        const status = data.status || "UNKNOWN";
        setStep("ingest", status === "COMPLETED" ? "done" : "working", status);
        els.uploadInfo.textContent = `Ingest status: ${status}`;
        addLog(`Ingest status: ${status}`, status === "COMPLETED" ? "success" : "info");
        if (data?.firestore?.manifest_uri) {
          els.manifestUri.value = data.firestore.manifest_uri;
        }
        if (status === "COMPLETED" && isVideoUpload()) {
          showStoryPanel();
          if (!state.story.loaded && !state.story.loading) {
            await loadVideoStory();
          }
        }
        return data;
      };

      const pollIngest = async () => {
        setStep("ingest", "working", "Polling...");
        const start = Date.now();
        while (Date.now() - start < 10 * 60 * 1000) {
          const status = await fetchIngestStatus();
          if (status.status === "COMPLETED") {
            return status;
          }
          if (status.status === "FAILED") {
            throw new Error("Ingest failed.");
          }
          await new Promise((resolve) => setTimeout(resolve, 5000));
        }
        throw new Error("Ingest polling timed out.");
      };

      const renderManifest = (manifest) => {
        els.manifestList.innerHTML = "";
        if (!manifest?.files?.length) {
          els.manifestList.textContent = "No files in manifest.";
          return;
        }
        manifest.files.forEach((file) => {
          const row = document.createElement("div");
          row.className = "preview-item";
          const label = document.createElement("span");
          label.textContent = file.uri || file.path || "unknown";
          const button = document.createElement("button");
          button.textContent = "Preview";
          button.className = "secondary";
          button.addEventListener("click", async () => {
            try {
              await previewParquet(file.uri);
            } catch (err) {
              addLog(err.message, "error");
            }
          });
          row.append(label, button);
          els.manifestList.append(row);
        });
      };

      const fetchManifest = async () => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        const manifestUriValue =
          els.manifestUri.value ||
          state.ingest?.firestore?.manifest_uri ||
          "";
        if (!manifestUriValue) {
          throw new Error("Manifest URI missing.");
        }
        setStep("manifest", "working", "Loading manifest...");
        const data = await apiFetch(
          `${devApi}/dev/manifest?manifest_uri_value=${encodeURIComponent(
            manifestUriValue
          )}`
        );
        state.manifest = data;
        setStep("manifest", "done", data.manifest_uri || "Loaded");
        addLog("Manifest loaded.", "success");
        renderManifest(data);
        autoPreviewModelOutputs();
        return data;
      };

      const previewParquet = async (uri) => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        if (!uri) {
          throw new Error("Missing parquet uri.");
        }
        els.previewMeta.textContent = `Previewing: ${uri}`;
        const data = await apiFetch(
          `${devApi}/dev/parquet-preview?path=${encodeURIComponent(uri)}`
        );
        state.preview = data;
        renderPreviewTable(data);
        return data;
      };

      const renderPreviewTable = (data) => {
        if (!data?.rows?.length) {
          els.previewTable.textContent = "No rows returned.";
          return;
        }
        const table = document.createElement("table");
        const head = document.createElement("tr");
        data.columns.forEach((col) => {
          const th = document.createElement("th");
          th.textContent = col;
          head.append(th);
        });
        table.append(head);
        data.rows.forEach((row) => {
          const tr = document.createElement("tr");
          data.columns.forEach((col) => {
            const td = document.createElement("td");
            const value = row[col];
            td.textContent =
              typeof value === "object" ? JSON.stringify(value) : String(value);
            tr.append(td);
          });
          table.append(tr);
        });
        els.previewTable.innerHTML = "";
        els.previewTable.append(table);
      };

      const autoPreviewModelOutputs = () => {
        if (!state.manifest?.files?.length) return;
        const vectorFile = state.manifest.files.find((file) =>
          (file.uri || "").includes("/vector/")
        );
        if (vectorFile) {
          previewParquet(vectorFile.uri).catch(() => {});
          return;
        }
        const textFile = state.manifest.files.find((file) =>
          (file.uri || "").includes("/text/")
        );
        if (textFile) {
          previewParquet(textFile.uri).catch(() => {});
        }
      };

      const triggerIndex = async () => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        setStep("index", "working", "Triggering index job...");
        const data = await apiFetch(`${devApi}/dev/index-build`, {
          method: "POST",
        });
        els.indexInfo.textContent = JSON.stringify(data, null, 2);
        addLog("Index job triggered.", "success");
        return data;
      };

      const indexStatus = async () => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        const data = await apiFetch(`${devApi}/dev/index-status`);
        els.indexInfo.textContent = JSON.stringify(data, null, 2);
        addLog("Index status fetched.", "info");
        return data;
      };

      const reloadSnapshot = async () => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        setStep("index", "working", "Reloading snapshot...");
        const data = await apiFetch(`${devApi}/dev/snapshot-reload`, {
          method: "POST",
        });
        setStep("index", "done", "Snapshot reloaded");
        els.indexInfo.textContent = JSON.stringify(data, null, 2);
        addLog("Snapshot reloaded.", "success");
        return data;
      };

      const runQuery = async () => {
        const { queryUrl } = getConfig();
        if (!queryUrl) {
          throw new Error("Query URL is required.");
        }
        setStep("query", "working", "Running query...");
        const payload = {
          query_text: els.queryText.value.trim(),
          top_k: Number(els.topK.value) || 5,
        };
        const data = await apiFetch(queryUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        els.queryResults.textContent = JSON.stringify(data, null, 2);
        setStep("query", "done", `Results: ${data?.results?.length || 0}`);
        addLog("Query complete.", "success");
        return data;
      };

      const runAll = async () => {
        try {
          await uploadFile();
          await pollIngest();
          await fetchManifest();
          await reloadSnapshot();
          await runQuery();
        } catch (err) {
          addLog(err.message, "error");
          setStep("query", "error", err.message);
        }
      };

      els.saveConfig.addEventListener("click", saveConfig);
      els.resetConfig.addEventListener("click", clearConfig);
      els.uploadBtn.addEventListener("click", async () => {
        try {
          await uploadFile();
        } catch (err) {
          addLog(err.message, "error");
          setStep("upload", "error", err.message);
        }
      });
      els.pollBtn.addEventListener("click", async () => {
        try {
          await pollIngest();
        } catch (err) {
          addLog(err.message, "error");
          setStep("ingest", "error", err.message);
        }
      });
      els.runAllBtn.addEventListener("click", runAll);
      els.manifestBtn.addEventListener("click", async () => {
        try {
          await fetchManifest();
        } catch (err) {
          addLog(err.message, "error");
          setStep("manifest", "error", err.message);
        }
      });
      els.indexBtn.addEventListener("click", async () => {
        try {
          await triggerIndex();
        } catch (err) {
          addLog(err.message, "error");
          setStep("index", "error", err.message);
        }
      });
      els.indexStatusBtn.addEventListener("click", async () => {
        try {
          await indexStatus();
        } catch (err) {
          addLog(err.message, "error");
        }
      });
      els.reloadBtn.addEventListener("click", async () => {
        try {
          await reloadSnapshot();
        } catch (err) {
          addLog(err.message, "error");
        }
      });
      els.queryBtn.addEventListener("click", async () => {
        try {
          await runQuery();
        } catch (err) {
          addLog(err.message, "error");
          setStep("query", "error", err.message);
        }
      });
      if (els.storyRefresh) {
        els.storyRefresh.addEventListener("click", async () => {
          try {
            await loadVideoStory();
          } catch (err) {
            addLog(err.message, "error");
          }
        });
      }
      els.storyTabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          activateStoryTab(tab.dataset.storyTab);
        });
      });

      loadConfig();
    </script>
  </body>
</html>
