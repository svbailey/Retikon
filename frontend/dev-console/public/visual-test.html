<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Retikon Visual Test</title>
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
    />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;600&family=Space+Grotesk:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg-1: #0b0f14;
        --bg-2: #101923;
        --bg-3: #0d1218;
        --panel: rgba(14, 22, 30, 0.82);
        --panel-strong: rgba(18, 27, 38, 0.95);
        --border: rgba(255, 255, 255, 0.08);
        --text: #edf2f7;
        --muted: #9aa9bb;
        --accent: #6ee7d2;
        --accent-2: #88a6ff;
        --accent-warm: #f1c36d;
        --danger: #ff6b6b;
        --success: #2bd987;
        --warning: #f1b34b;
        --shadow: 0 20px 60px rgba(5, 8, 12, 0.55);
        --radius: 18px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Manrope", "Space Grotesk", sans-serif;
        color: var(--text);
        background: radial-gradient(
            circle at 12% 16%,
            rgba(110, 231, 210, 0.2),
            transparent 50%
          ),
          radial-gradient(
            circle at 86% 8%,
            rgba(136, 166, 255, 0.18),
            transparent 45%
          ),
          linear-gradient(160deg, var(--bg-1), var(--bg-2));
        min-height: 100vh;
        padding: 40px 24px 80px;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background-image: linear-gradient(
            rgba(255, 255, 255, 0.035) 1px,
            transparent 1px
          ),
          linear-gradient(
            90deg,
            rgba(255, 255, 255, 0.035) 1px,
            transparent 1px
          );
        background-size: 32px 32px;
        pointer-events: none;
        opacity: 0.25;
      }

      .shell {
        max-width: 1200px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 24px;
        position: relative;
        z-index: 1;
      }

      header {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      h1 {
        font-family: "Space Grotesk", "Manrope", sans-serif;
        font-size: 2.6rem;
        margin: 0;
        letter-spacing: -0.02em;
      }

      .subtitle {
        color: var(--muted);
        max-width: 740px;
        line-height: 1.6;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 20px;
      }

      .panel {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        padding: 20px;
        box-shadow: var(--shadow);
        animation: fadeUp 0.6s ease both;
      }

      .panel strong {
        font-family: "Space Grotesk", "Manrope", sans-serif;
      }

      .panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
      }

      .panel-header h2 {
        margin: 0;
        font-size: 1.2rem;
        letter-spacing: -0.01em;
      }

      .pill {
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }

      .pill.accent {
        background: rgba(244, 183, 64, 0.18);
        color: var(--accent);
      }

      .field {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-bottom: 12px;
      }

      label {
        font-size: 0.85rem;
        color: var(--muted);
      }

      input,
      select,
      textarea,
      button {
        font-family: "Manrope", sans-serif;
      }

      input,
      select,
      textarea {
        background: rgba(5, 10, 14, 0.6);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        color: var(--text);
        font-size: 0.9rem;
      }

      textarea {
        min-height: 120px;
        resize: vertical;
      }

      button {
        background: linear-gradient(120deg, var(--accent), #ffdb8c);
        border: none;
        border-radius: 12px;
        padding: 10px 16px;
        font-weight: 700;
        color: #151515;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      button.secondary {
        background: rgba(255, 255, 255, 0.08);
        color: var(--text);
        border: 1px solid var(--border);
      }

      button.ghost {
        background: transparent;
        color: var(--muted);
        border: 1px dashed var(--border);
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      button:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 10px 22px rgba(0, 0, 0, 0.25);
      }

      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .steps {
        display: grid;
        gap: 10px;
      }

      .step-card {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 12px 14px;
        background: rgba(9, 15, 21, 0.6);
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .step-card[data-state="working"] {
        border-color: rgba(62, 212, 197, 0.6);
        box-shadow: 0 0 0 1px rgba(62, 212, 197, 0.2);
      }

      .step-card[data-state="done"] {
        border-color: rgba(43, 217, 135, 0.6);
      }

      .step-card[data-state="error"] {
        border-color: rgba(255, 107, 107, 0.6);
      }

      .step-title {
        font-weight: 600;
      }

      .step-status {
        font-size: 0.8rem;
        color: var(--muted);
      }

      .step-detail {
        font-size: 0.85rem;
        color: var(--text);
      }

      .log {
        display: grid;
        gap: 6px;
        max-height: 180px;
        overflow: auto;
        font-size: 0.85rem;
      }

      .log-item {
        padding: 8px 10px;
        border-radius: 10px;
        background: rgba(9, 15, 21, 0.6);
        border: 1px solid var(--border);
      }

      .log-item.info {
        color: var(--muted);
      }

      .log-item.success {
        color: var(--success);
      }

      .log-item.error {
        color: var(--danger);
      }

      .data-block {
        background: rgba(5, 10, 14, 0.6);
        border-radius: 12px;
        border: 1px solid var(--border);
        padding: 12px;
        font-size: 0.82rem;
        overflow: auto;
        max-height: 240px;
        white-space: pre-wrap;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.82rem;
      }

      th,
      td {
        text-align: left;
        padding: 6px 8px;
        border-bottom: 1px solid var(--border);
        vertical-align: top;
      }

      th {
        color: var(--muted);
        font-weight: 600;
      }

      .tag {
        display: inline-flex;
        padding: 2px 8px;
        border-radius: 999px;
        font-size: 0.7rem;
        background: rgba(62, 212, 197, 0.2);
        color: var(--accent-2);
      }

      .inline {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .notice {
        font-size: 0.82rem;
        color: var(--muted);
        line-height: 1.5;
      }

      .preview-list {
        display: grid;
        gap: 10px;
        margin-top: 10px;
      }

      .preview-item {
        display: flex;
        justify-content: space-between;
        gap: 10px;
        align-items: center;
        font-size: 0.82rem;
      }

      .story-panel.hidden {
        display: none;
      }

      .story-grid {
        display: grid;
        grid-template-columns: minmax(0, 1.2fr) minmax(0, 0.8fr);
        gap: 16px;
        margin-top: 12px;
      }

      .story-video {
        background: var(--panel-strong);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .story-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .story-header h3 {
        margin: 0;
        font-size: 1rem;
      }

      .story-video video {
        width: 100%;
        border-radius: 14px;
        background: #000;
      }

      .story-meta {
        display: grid;
        gap: 6px;
        font-size: 0.82rem;
        color: var(--muted);
      }

      .story-meta strong {
        color: var(--text);
      }

      .story-meta span {
        word-break: break-all;
      }

      .story-facts {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 12px;
        align-content: start;
      }

      .fact-card {
        background: var(--panel-strong);
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-height: 72px;
      }

      .fact-label {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--muted);
      }

      .fact-value {
        font-size: 1.1rem;
        font-weight: 600;
      }

      .story-tabs {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 16px;
      }

      .story-tab {
        background: rgba(5, 10, 14, 0.6);
        border: 1px solid var(--border);
        color: var(--muted);
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 0.78rem;
        cursor: pointer;
      }

      .story-tab.active {
        background: rgba(244, 183, 64, 0.2);
        border-color: rgba(244, 183, 64, 0.5);
        color: var(--accent);
      }

      .story-tab-content {
        display: none;
        margin-top: 12px;
      }

      .story-tab-content.active {
        display: block;
      }

      .story-summary {
        display: grid;
        gap: 8px;
      }

      .summary-item {
        background: rgba(5, 10, 14, 0.5);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 0.85rem;
      }

      .label-section {
        background: rgba(5, 10, 14, 0.5);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px;
        display: grid;
        gap: 8px;
      }

      .label-section h4 {
        margin: 0;
        font-size: 0.72rem;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--muted);
      }

      .label-chip-group {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .label-chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 0.75rem;
        color: rgba(245, 241, 233, 0.92);
        background: rgba(255, 255, 255, 0.12);
        border: 1px solid rgba(255, 255, 255, 0.16);
      }

      .label-chip span {
        opacity: 0.7;
        font-size: 0.7rem;
      }

      .label-meta {
        margin-top: 8px;
        font-size: 0.78rem;
        color: var(--muted);
      }

      .keyframe-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 12px;
      }

      .keyframe-card {
        background: rgba(5, 10, 14, 0.5);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 8px;
        display: grid;
        gap: 6px;
      }

      .keyframe-card img {
        width: 100%;
        border-radius: 10px;
        display: block;
      }

      .keyframe-time {
        font-size: 0.78rem;
        color: var(--muted);
        text-align: center;
      }

      @keyframes fadeUp {
        from {
          opacity: 0;
          transform: translateY(14px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (max-width: 720px) {
        body {
          padding: 24px 16px 60px;
        }
        h1 {
          font-size: 2rem;
        }
      }

      @media (max-width: 900px) {
        .story-grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <main class="shell">
      <header>
        <span class="pill accent">visual test</span>
        <h1>Retikon staging visual run</h1>
        <p class="subtitle">
          Upload a document, watch ingestion progress, preview model outputs,
          then run a simple query. Keep this page open during the run.
        </p>
      </header>

      <section class="grid">
        <div class="panel">
          <div class="panel-header">
            <h2>Configuration</h2>
          </div>
          <div class="field">
            <label>JWT / AI token</label>
            <input id="jwt" type="password" placeholder="Paste JWT" />
          </div>
          <div class="field">
            <label>Dev API URL</label>
            <input
              id="devApi"
              type="url"
              placeholder="https://retikon-dev-console-...run.app"
            />
          </div>
          <div class="field">
            <label>Query URL</label>
            <input
              id="queryUrl"
              type="url"
              placeholder="https://retikon-query-...run.app/query"
            />
          </div>
          <div class="inline">
            <button id="saveConfig" class="secondary">Save</button>
            <button id="resetConfig" class="ghost">Clear</button>
          </div>
          <p class="notice">
            Values are saved locally in your browser. JWT must include required
            claims (org_id at minimum).
          </p>
        </div>

        <div class="panel">
          <div class="panel-header">
            <h2>Run state</h2>
          </div>
          <div class="steps">
            <div class="step-card" data-step="upload" data-state="idle">
              <div class="step-title">1. Upload</div>
              <div class="step-status">idle</div>
              <div class="step-detail">Awaiting file</div>
            </div>
            <div class="step-card" data-step="ingest" data-state="idle">
              <div class="step-title">2. Ingest</div>
              <div class="step-status">idle</div>
              <div class="step-detail">No status yet</div>
            </div>
            <div class="step-card" data-step="manifest" data-state="idle">
              <div class="step-title">3. Manifest</div>
              <div class="step-status">idle</div>
              <div class="step-detail">Manifest not loaded</div>
            </div>
            <div class="step-card" data-step="index" data-state="idle">
              <div class="step-title">4. Index + Reload</div>
              <div class="step-status">idle</div>
              <div class="step-detail">Not triggered</div>
            </div>
            <div class="step-card" data-step="query" data-state="idle">
              <div class="step-title">5. Query</div>
              <div class="step-status">idle</div>
              <div class="step-detail">No query yet</div>
            </div>
          </div>
        </div>
      </section>

      <section class="grid">
        <div class="panel">
          <div class="panel-header">
            <h2>Upload + ingest</h2>
          </div>
          <div class="field">
            <label>File</label>
            <input id="fileInput" type="file" />
          </div>
          <div class="field">
            <label>Category</label>
            <select id="category">
              <option value="docs">docs</option>
              <option value="images">images</option>
              <option value="audio">audio</option>
              <option value="videos">video</option>
            </select>
          </div>
          <div class="actions">
            <button id="uploadBtn">Upload</button>
            <button id="pollBtn" class="secondary">Poll ingest</button>
            <button id="runAllBtn" class="ghost">Run end-to-end</button>
          </div>
          <div class="notice" id="uploadInfo">No upload yet.</div>
        </div>

        <div class="panel">
          <div class="panel-header">
            <h2>Activity</h2>
          </div>
          <div class="log" id="activityLog"></div>
        </div>
      </section>

      <section class="grid">
        <div class="panel">
          <div class="panel-header">
            <h2>Manifest + model outputs</h2>
          </div>
          <div class="field">
            <label>Manifest URI (optional override)</label>
            <input
              id="manifestUri"
              type="text"
              placeholder="gs://.../manifests/<run-id>/manifest.json"
            />
          </div>
          <div class="actions">
            <button id="manifestBtn">Load manifest</button>
          </div>
          <div class="preview-list" id="manifestList"></div>
        </div>

        <div class="panel">
          <div class="panel-header">
            <h2>Preview</h2>
          </div>
          <div id="previewMeta" class="notice">
            Preview a manifest file to see sample rows.
          </div>
          <div id="previewTable" class="data-block"></div>
        </div>
      </section>

      <section class="grid">
        <div class="panel">
          <div class="panel-header">
            <h2>Index + snapshot</h2>
          </div>
          <div class="actions">
            <button id="indexBtn" class="secondary">Trigger index</button>
            <button id="indexStatusBtn" class="ghost">Index status</button>
            <button id="reloadBtn">Reload snapshot</button>
          </div>
          <div class="notice" id="indexInfo">No index action yet.</div>
        </div>

        <div class="panel">
          <div class="panel-header">
            <h2>Query</h2>
          </div>
          <div class="field">
            <label>Query text</label>
            <input id="queryText" type="text" value="Retikon demo query" />
          </div>
          <div class="field">
            <label>Top K</label>
            <input id="topK" type="number" min="1" max="50" value="5" />
          </div>
          <div class="actions">
            <button id="queryBtn">Run query</button>
          </div>
          <div class="data-block" id="queryResults">No query yet.</div>
        </div>
      </section>

      <section class="panel story-panel hidden" id="storyPanel">
        <div class="panel-header">
          <h2>Video Story</h2>
          <span class="pill accent">post-ingest</span>
        </div>
        <p class="notice" id="storyStatus">
          Upload a video and complete ingestion to reveal a human-friendly
          summary of what the system learned.
        </p>

        <div class="story-grid">
          <div class="story-video">
            <div class="story-header">
              <div>
                <h3>Your video</h3>
                <p class="notice">Playback plus the facts extracted into the graph.</p>
              </div>
              <button id="storyRefresh" class="secondary">Refresh story</button>
            </div>
            <video id="storyVideo" controls></video>
            <div class="story-meta" id="storyVideoMeta">Video preview not loaded.</div>
            <div class="story-meta">
              <div><strong>Source</strong> <span id="storySourceUri">-</span></div>
              <div><strong>Manifest</strong> <span id="storyManifestUri">-</span></div>
            </div>
          </div>

          <div class="story-facts" id="storyFacts">
            <div class="fact-card">
              <span class="fact-label">Duration</span>
              <span class="fact-value" id="storyDuration">-</span>
            </div>
            <div class="fact-card">
              <span class="fact-label">Resolution</span>
              <span class="fact-value" id="storyResolution">-</span>
            </div>
            <div class="fact-card">
              <span class="fact-label">Frames</span>
              <span class="fact-value" id="storyFrames">-</span>
            </div>
            <div class="fact-card">
              <span class="fact-label">Audio</span>
              <span class="fact-value" id="storyAudio">-</span>
            </div>
            <div class="fact-card">
              <span class="fact-label">File size</span>
              <span class="fact-value" id="storySize">-</span>
            </div>
            <div class="fact-card">
              <span class="fact-label">Transcript</span>
              <span class="fact-value" id="storyTranscriptCount">-</span>
            </div>
            <div class="fact-card">
              <span class="fact-label">Keyframes</span>
              <span class="fact-value" id="storyKeyframeCount">-</span>
            </div>
            <div class="fact-card">
              <span class="fact-label">Relations</span>
              <span class="fact-value" id="storyRelationCount">-</span>
            </div>
          </div>
        </div>

        <div class="story-tabs">
          <button class="story-tab active" data-story-tab="highlights">
            Highlights
          </button>
          <button class="story-tab" data-story-tab="transcript">Transcript</button>
          <button class="story-tab" data-story-tab="labels">Visual Labels</button>
          <button class="story-tab" data-story-tab="keyframes">Keyframes</button>
        </div>

        <div class="story-tab-content active" data-story-content="highlights">
          <div class="story-summary" id="storySummary"></div>
        </div>
        <div class="story-tab-content" data-story-content="transcript">
          <div class="data-block" id="storyTranscript">
            Transcript will appear here after ingest completes.
          </div>
        </div>
        <div class="story-tab-content" data-story-content="labels">
          <div class="label-section">
            <h4>Objects</h4>
            <div class="label-chip-group" id="storyLabelObjects">
              Labels will appear after ingest completes.
            </div>
          </div>
          <div class="label-section" style="margin-top: 12px;">
            <h4>Scenes</h4>
            <div class="label-chip-group" id="storyLabelScenes"></div>
          </div>
          <div class="label-section" style="margin-top: 12px;">
            <h4>Actions</h4>
            <div class="label-chip-group" id="storyLabelActions"></div>
          </div>
          <div class="label-meta" id="storyLabelMeta"></div>
        </div>
        <div class="story-tab-content" data-story-content="keyframes">
          <div class="keyframe-grid" id="storyKeyframes"></div>
        </div>
      </section>
    </main>

    <script>
      const state = {
        upload: null,
        ingest: null,
        manifest: null,
        preview: null,
        story: {
          loaded: false,
          loading: false,
          thumbs: {},
        },
      };

      const els = {
        jwt: document.getElementById("jwt"),
        devApi: document.getElementById("devApi"),
        queryUrl: document.getElementById("queryUrl"),
        saveConfig: document.getElementById("saveConfig"),
        resetConfig: document.getElementById("resetConfig"),
        fileInput: document.getElementById("fileInput"),
        category: document.getElementById("category"),
        uploadBtn: document.getElementById("uploadBtn"),
        pollBtn: document.getElementById("pollBtn"),
        runAllBtn: document.getElementById("runAllBtn"),
        uploadInfo: document.getElementById("uploadInfo"),
        activityLog: document.getElementById("activityLog"),
        manifestUri: document.getElementById("manifestUri"),
        manifestBtn: document.getElementById("manifestBtn"),
        manifestList: document.getElementById("manifestList"),
        previewMeta: document.getElementById("previewMeta"),
        previewTable: document.getElementById("previewTable"),
        indexBtn: document.getElementById("indexBtn"),
        indexStatusBtn: document.getElementById("indexStatusBtn"),
        reloadBtn: document.getElementById("reloadBtn"),
        indexInfo: document.getElementById("indexInfo"),
        queryText: document.getElementById("queryText"),
        topK: document.getElementById("topK"),
        queryBtn: document.getElementById("queryBtn"),
        queryResults: document.getElementById("queryResults"),
        storyPanel: document.getElementById("storyPanel"),
        storyStatus: document.getElementById("storyStatus"),
        storyRefresh: document.getElementById("storyRefresh"),
        storyVideo: document.getElementById("storyVideo"),
        storyVideoMeta: document.getElementById("storyVideoMeta"),
        storySourceUri: document.getElementById("storySourceUri"),
        storyManifestUri: document.getElementById("storyManifestUri"),
        storyDuration: document.getElementById("storyDuration"),
        storyResolution: document.getElementById("storyResolution"),
        storyFrames: document.getElementById("storyFrames"),
        storyAudio: document.getElementById("storyAudio"),
        storySize: document.getElementById("storySize"),
        storyTranscriptCount: document.getElementById("storyTranscriptCount"),
        storyKeyframeCount: document.getElementById("storyKeyframeCount"),
        storyRelationCount: document.getElementById("storyRelationCount"),
        storySummary: document.getElementById("storySummary"),
        storyTranscript: document.getElementById("storyTranscript"),
        storyLabelObjects: document.getElementById("storyLabelObjects"),
        storyLabelScenes: document.getElementById("storyLabelScenes"),
        storyLabelActions: document.getElementById("storyLabelActions"),
        storyLabelMeta: document.getElementById("storyLabelMeta"),
        storyKeyframes: document.getElementById("storyKeyframes"),
        storyTabs: Array.from(document.querySelectorAll("[data-story-tab]")),
        storyContents: Array.from(
          document.querySelectorAll("[data-story-content]"),
        ),
      };

      const STORAGE_KEY = "retikon_visual_test_config";

      const setStep = (step, stateLabel, detail) => {
        const card = document.querySelector(`[data-step="${step}"]`);
        if (!card) return;
        card.dataset.state = stateLabel;
        card.querySelector(".step-status").textContent = stateLabel;
        if (detail) {
          card.querySelector(".step-detail").textContent = detail;
        }
      };

      const addLog = (message, tone = "info") => {
        const item = document.createElement("div");
        item.className = `log-item ${tone}`;
        item.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
        els.activityLog.prepend(item);
      };

      const getConfig = () => ({
        jwt: els.jwt.value.replace(/\s+/g, ""),
        devApi: els.devApi.value.trim().replace(/\/$/, ""),
        queryUrl: els.queryUrl.value.trim(),
      });

      const authHeaders = () => {
        const { jwt } = getConfig();
        return jwt ? { Authorization: `Bearer ${jwt}` } : {};
      };

      const saveConfig = () => {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(getConfig()));
        addLog("Configuration saved.", "success");
      };

      const loadConfig = () => {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        try {
          const cfg = JSON.parse(raw);
          els.jwt.value = cfg.jwt || "";
          els.devApi.value = cfg.devApi || "";
          els.queryUrl.value = cfg.queryUrl || "";
        } catch (err) {
          addLog("Failed to load saved config.", "error");
        }
      };

      const clearConfig = () => {
        localStorage.removeItem(STORAGE_KEY);
        els.jwt.value = "";
        els.devApi.value = "";
        els.queryUrl.value = "";
        addLog("Configuration cleared.", "info");
      };

      const apiFetch = async (url, options = {}) => {
        const resp = await fetch(url, {
          ...options,
          headers: {
            ...(options.headers || {}),
            ...authHeaders(),
          },
        });
        if (!resp.ok) {
          const text = await resp.text();
          throw new Error(text || `Request failed (${resp.status})`);
        }
        return resp.json();
      };

      const formatBytes = (value) => {
        if (!value && value !== 0) return "-";
        const units = ["B", "KB", "MB", "GB"];
        let size = Number(value);
        let unit = 0;
        while (size >= 1024 && unit < units.length - 1) {
          size /= 1024;
          unit += 1;
        }
        return `${size.toFixed(size >= 10 || unit === 0 ? 0 : 1)} ${units[unit]}`;
      };

      const formatDuration = (ms) => {
        if (!ms && ms !== 0) return "-";
        const totalSeconds = Math.floor(Number(ms) / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}:${String(seconds).padStart(2, "0")}`;
      };

      const formatTimestamp = (ms) => {
        if (!ms && ms !== 0) return "-";
        return formatDuration(ms);
      };

      const setStoryValue = (el, value) => {
        if (!el) return;
        el.textContent = value ?? "-";
      };

      const showStoryPanel = () => {
        els.storyPanel?.classList.remove("hidden");
      };

      const activateStoryTab = (name) => {
        els.storyTabs.forEach((tab) => {
          tab.classList.toggle("active", tab.dataset.storyTab === name);
        });
        els.storyContents.forEach((content) => {
          content.classList.toggle(
            "active",
            content.dataset.storyContent === name,
          );
        });
      };

      const fetchBinary = async (url) => {
        const resp = await fetch(url, { headers: authHeaders() });
        if (!resp.ok) {
          const text = await resp.text();
          throw new Error(text || `Request failed (${resp.status})`);
        }
        return resp.blob();
      };

      const fetchRawObject = async (uri) => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        const target = `${devApi}/dev/object?uri=${encodeURIComponent(uri)}`;
        return fetchBinary(target);
      };

      const fetchGraphObject = async (uri) => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        const target = `${devApi}/dev/graph-object?uri=${encodeURIComponent(uri)}`;
        return fetchBinary(target);
      };

      const fetchVisualLabels = async (mediaAssetId) => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        const target =
          `${devApi}/dev/visual-labels?media_asset_id=${encodeURIComponent(
            mediaAssetId,
          )}&top_k=8&max_frames=12`;
        return apiFetch(target);
      };

      const renderLabelChips = (el, items) => {
        if (!el) return;
        el.innerHTML = "";
        if (!items?.length) {
          el.textContent = "No labels available.";
          return;
        }
        items.forEach((item) => {
          const chip = document.createElement("div");
          chip.className = "label-chip";
          const label = document.createElement("strong");
          label.textContent = item.label;
          const score = document.createElement("span");
          score.textContent = `${Math.round((item.score || 0) * 100)}%`;
          chip.append(label, score);
          el.append(chip);
        });
      };

      const uploadFile = async () => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        const file = els.fileInput.files[0];
        if (!file) {
          throw new Error("Choose a file before uploading.");
        }
        setStep("upload", "working", "Uploading file...");
        addLog("Uploading file to raw bucket...", "info");
        const form = new FormData();
        form.append("file", file);
        form.append("category", els.category.value);
        const resp = await fetch(`${devApi}/dev/upload`, {
          method: "POST",
          headers: authHeaders(),
          body: form,
        });
        if (!resp.ok) {
          const text = await resp.text();
          throw new Error(text || "Upload failed");
        }
        const data = await resp.json();
        state.upload = data;
        state.story.loaded = false;
        state.story.loading = false;
        state.story.thumbs = {};
        if (els.storyPanel) {
          els.storyPanel.classList.add("hidden");
        }
        if (els.storyVideo) {
          els.storyVideo.removeAttribute("src");
        }
        if (els.storyVideoMeta) {
          els.storyVideoMeta.textContent = "Video preview not loaded.";
        }
        if (els.storyLabelObjects) {
          els.storyLabelObjects.textContent =
            "Labels will appear after ingest completes.";
        }
        if (els.storyLabelScenes) {
          els.storyLabelScenes.textContent = "";
        }
        if (els.storyLabelActions) {
          els.storyLabelActions.textContent = "";
        }
        if (els.storyLabelMeta) {
          els.storyLabelMeta.textContent = "";
        }
        els.uploadInfo.textContent = `Uploaded ${data.name} (${data.size_bytes} bytes)`;
        setStep("upload", "done", `URI: ${data.uri}`);
        addLog("Upload complete.", "success");
        return data;
      };

      const isVideoUpload = () =>
        Boolean(state.upload?.name && state.upload.name.includes("/videos/"));

      const loadVideoStory = async () => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        if (!isVideoUpload()) {
          els.storyStatus.textContent =
            "Video story is only available for video uploads.";
          return;
        }
        const manifestUri = state.ingest?.firestore?.manifest_uri;
        if (!manifestUri) {
          els.storyStatus.textContent =
            "Waiting for manifest data from ingestion.";
          return;
        }
        if (state.story.loading) {
          return;
        }
        state.story.loading = true;
        showStoryPanel();
        els.storyStatus.textContent = "Building your video story...";

        try {
          const manifest = await apiFetch(
            `${devApi}/dev/manifest?manifest_uri_value=${encodeURIComponent(
              manifestUri
            )}`
          );
          const files = manifest.files || [];
          const counts = manifest.counts || state.ingest?.firestore?.counts || {};
          const findFile = (needle) =>
            files.find((file) =>
              String(file.uri || file.path || "").includes(needle)
            );
          const mediaFile = findFile("/vertices/MediaAsset/core/");
          const imageFile = findFile("/vertices/ImageAsset/core/");
          const transcriptFile = findFile("/vertices/Transcript/text/");
          const mediaPreview = mediaFile?.uri
            ? await apiFetch(
                `${devApi}/dev/parquet-preview?path=${encodeURIComponent(
                  mediaFile.uri
                )}&limit=5`
              )
            : null;
          const imagePreview = imageFile?.uri
            ? await apiFetch(
                `${devApi}/dev/parquet-preview?path=${encodeURIComponent(
                  imageFile.uri
                )}&limit=20`
              )
            : null;
          const transcriptPreview = transcriptFile?.uri
            ? await apiFetch(
                `${devApi}/dev/parquet-preview?path=${encodeURIComponent(
                  transcriptFile.uri
                )}&limit=6`
              )
            : null;

          const mediaTargetId = state.ingest?.firestore?.media_asset_id;
          const mediaRow =
            mediaPreview?.rows?.find((row) => row.id === mediaTargetId) ||
            mediaPreview?.rows?.[0] ||
            null;
          const imageRows = (imagePreview?.rows || []).filter((row) =>
            mediaTargetId ? row.media_asset_id === mediaTargetId : true
          );
          const transcriptRows = transcriptPreview?.rows || [];

          setStoryValue(els.storyDuration, formatDuration(mediaRow?.duration_ms));
          setStoryValue(
            els.storyResolution,
            mediaRow?.width_px && mediaRow?.height_px
              ? `${mediaRow.width_px} x ${mediaRow.height_px}`
              : "-"
          );
          setStoryValue(
            els.storyFrames,
            mediaRow?.frame_count ?? counts.ImageAsset ?? "-"
          );
          setStoryValue(
            els.storyAudio,
            (counts.AudioClip || 0) > 0 ? "Yes" : "No"
          );
          setStoryValue(els.storySize, formatBytes(mediaRow?.size_bytes));
          setStoryValue(
            els.storyTranscriptCount,
            counts.Transcript ?? transcriptRows.length ?? "-"
          );
          setStoryValue(
            els.storyKeyframeCount,
            counts.ImageAsset ?? imageRows.length ?? "-"
          );
          setStoryValue(els.storyRelationCount, counts.DerivedFrom ?? "-");
          setStoryValue(els.storySourceUri, mediaRow?.uri || state.upload?.uri);
          setStoryValue(els.storyManifestUri, manifest.manifest_uri || manifestUri);

          if (state.story.videoUrl) {
            URL.revokeObjectURL(state.story.videoUrl);
            state.story.videoUrl = null;
          }
          if (mediaRow?.uri || state.upload?.uri) {
            try {
              const blob = await fetchRawObject(mediaRow?.uri || state.upload?.uri);
              const objectUrl = URL.createObjectURL(blob);
              state.story.videoUrl = objectUrl;
              els.storyVideo.src = objectUrl;
              els.storyVideoMeta.textContent = "Video preview ready.";
            } catch (err) {
              els.storyVideoMeta.textContent = `Video preview unavailable: ${
                err.message || err
              }`;
            }
          }

          const summaryItems = [];
          if (mediaRow?.duration_ms) {
            summaryItems.push(
              `This video is ${formatDuration(
                mediaRow.duration_ms
              )} long at ${mediaRow.width_px} x ${mediaRow.height_px}.`
            );
          }
          if (counts.ImageAsset) {
            summaryItems.push(
              `We captured ${counts.ImageAsset} keyframes to represent the visuals.`
            );
          }
          if (counts.Transcript) {
            summaryItems.push(
              `We generated ${counts.Transcript} transcript segments from the audio.`
            );
          }
          if (counts.DerivedFrom) {
            summaryItems.push(
              `${counts.DerivedFrom} relationships link frames, transcript, and the source asset.`
            );
          }
          els.storySummary.innerHTML = "";
          if (summaryItems.length === 0) {
            els.storySummary.textContent = "No summary yet.";
          } else {
            summaryItems.forEach((text) => {
              const item = document.createElement("div");
              item.className = "summary-item";
              item.textContent = text;
              els.storySummary.append(item);
            });
          }

          const transcriptText = transcriptRows
            .map((row) => row.content)
            .filter(Boolean);
          els.storyTranscript.textContent = transcriptText.length
            ? transcriptText.map((line) => `â€¢ ${line}`).join("\n")
            : "No transcript segments were recorded.";

          els.storyKeyframes.innerHTML = "";
          if (!imageRows.length) {
            els.storyKeyframes.textContent = "No keyframes found.";
          } else {
            for (const row of imageRows.slice(0, 12)) {
              const card = document.createElement("div");
              card.className = "keyframe-card";
              const img = document.createElement("img");
              img.alt = `Keyframe at ${formatTimestamp(row.timestamp_ms)}`;
              const time = document.createElement("div");
              time.className = "keyframe-time";
              time.textContent = formatTimestamp(row.timestamp_ms);
              card.append(img, time);
              els.storyKeyframes.append(card);
              if (row.thumbnail_uri) {
                try {
                  if (!state.story.thumbs[row.thumbnail_uri]) {
                    const blob = await fetchGraphObject(row.thumbnail_uri);
                    state.story.thumbs[row.thumbnail_uri] =
                      URL.createObjectURL(blob);
                  }
                  img.src = state.story.thumbs[row.thumbnail_uri];
                } catch (err) {
                  img.alt = "Thumbnail unavailable.";
                }
              }
            }
          }

          if (mediaTargetId) {
            try {
              const labelData = await fetchVisualLabels(mediaTargetId);
              renderLabelChips(
                els.storyLabelObjects,
                labelData.labels?.object || [],
              );
              renderLabelChips(
                els.storyLabelScenes,
                labelData.labels?.scene || [],
              );
              renderLabelChips(
                els.storyLabelActions,
                labelData.labels?.action || [],
              );
              if (els.storyLabelMeta) {
                els.storyLabelMeta.textContent = `Model backend: ${labelData.backend} | Frames scored: ${labelData.frame_count}`;
              }
            } catch (err) {
              if (els.storyLabelMeta) {
                els.storyLabelMeta.textContent = `Labels unavailable: ${
                  err.message || err
                }`;
              }
            }
          }

          els.storyStatus.textContent =
            "Video story ready. Explore transcript and keyframes below.";
          state.story.loaded = true;
          activateStoryTab("highlights");
        } finally {
          state.story.loading = false;
        }
      };

      const fetchIngestStatus = async () => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        if (!state.upload?.uri) {
          throw new Error("Upload a file first.");
        }
        const uri = encodeURIComponent(state.upload.uri);
        const data = await apiFetch(`${devApi}/dev/ingest-status?uri=${uri}`);
        state.ingest = data;
        const status = data.status || "UNKNOWN";
        setStep("ingest", status === "COMPLETED" ? "done" : "working", status);
        els.uploadInfo.textContent = `Ingest status: ${status}`;
        addLog(`Ingest status: ${status}`, status === "COMPLETED" ? "success" : "info");
        if (data?.firestore?.manifest_uri) {
          els.manifestUri.value = data.firestore.manifest_uri;
        }
        if (status === "COMPLETED" && isVideoUpload()) {
          showStoryPanel();
          if (!state.story.loaded && !state.story.loading) {
            await loadVideoStory();
          }
        }
        return data;
      };

      const pollIngest = async () => {
        setStep("ingest", "working", "Polling...");
        const start = Date.now();
        while (Date.now() - start < 10 * 60 * 1000) {
          const status = await fetchIngestStatus();
          if (status.status === "COMPLETED") {
            return status;
          }
          if (status.status === "FAILED") {
            throw new Error("Ingest failed.");
          }
          await new Promise((resolve) => setTimeout(resolve, 5000));
        }
        throw new Error("Ingest polling timed out.");
      };

      const renderManifest = (manifest) => {
        els.manifestList.innerHTML = "";
        if (!manifest?.files?.length) {
          els.manifestList.textContent = "No files in manifest.";
          return;
        }
        manifest.files.forEach((file) => {
          const row = document.createElement("div");
          row.className = "preview-item";
          const label = document.createElement("span");
          label.textContent = file.uri || file.path || "unknown";
          const button = document.createElement("button");
          button.textContent = "Preview";
          button.className = "secondary";
          button.addEventListener("click", async () => {
            try {
              await previewParquet(file.uri);
            } catch (err) {
              addLog(err.message, "error");
            }
          });
          row.append(label, button);
          els.manifestList.append(row);
        });
      };

      const fetchManifest = async () => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        const manifestUriValue =
          els.manifestUri.value ||
          state.ingest?.firestore?.manifest_uri ||
          "";
        if (!manifestUriValue) {
          throw new Error("Manifest URI missing.");
        }
        setStep("manifest", "working", "Loading manifest...");
        const data = await apiFetch(
          `${devApi}/dev/manifest?manifest_uri_value=${encodeURIComponent(
            manifestUriValue
          )}`
        );
        state.manifest = data;
        setStep("manifest", "done", data.manifest_uri || "Loaded");
        addLog("Manifest loaded.", "success");
        renderManifest(data);
        autoPreviewModelOutputs();
        return data;
      };

      const previewParquet = async (uri) => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        if (!uri) {
          throw new Error("Missing parquet uri.");
        }
        els.previewMeta.textContent = `Previewing: ${uri}`;
        const data = await apiFetch(
          `${devApi}/dev/parquet-preview?path=${encodeURIComponent(uri)}`
        );
        state.preview = data;
        renderPreviewTable(data);
        return data;
      };

      const renderPreviewTable = (data) => {
        if (!data?.rows?.length) {
          els.previewTable.textContent = "No rows returned.";
          return;
        }
        const table = document.createElement("table");
        const head = document.createElement("tr");
        data.columns.forEach((col) => {
          const th = document.createElement("th");
          th.textContent = col;
          head.append(th);
        });
        table.append(head);
        data.rows.forEach((row) => {
          const tr = document.createElement("tr");
          data.columns.forEach((col) => {
            const td = document.createElement("td");
            const value = row[col];
            td.textContent =
              typeof value === "object" ? JSON.stringify(value) : String(value);
            tr.append(td);
          });
          table.append(tr);
        });
        els.previewTable.innerHTML = "";
        els.previewTable.append(table);
      };

      const autoPreviewModelOutputs = () => {
        if (!state.manifest?.files?.length) return;
        const vectorFile = state.manifest.files.find((file) =>
          (file.uri || "").includes("/vector/")
        );
        if (vectorFile) {
          previewParquet(vectorFile.uri).catch(() => {});
          return;
        }
        const textFile = state.manifest.files.find((file) =>
          (file.uri || "").includes("/text/")
        );
        if (textFile) {
          previewParquet(textFile.uri).catch(() => {});
        }
      };

      const triggerIndex = async () => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        setStep("index", "working", "Triggering index job...");
        const data = await apiFetch(`${devApi}/dev/index-build`, {
          method: "POST",
        });
        els.indexInfo.textContent = JSON.stringify(data, null, 2);
        addLog("Index job triggered.", "success");
        return data;
      };

      const indexStatus = async () => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        const data = await apiFetch(`${devApi}/dev/index-status`);
        els.indexInfo.textContent = JSON.stringify(data, null, 2);
        addLog("Index status fetched.", "info");
        return data;
      };

      const reloadSnapshot = async () => {
        const { devApi } = getConfig();
        if (!devApi) {
          throw new Error("Dev API URL is required.");
        }
        setStep("index", "working", "Reloading snapshot...");
        const data = await apiFetch(`${devApi}/dev/snapshot-reload`, {
          method: "POST",
        });
        setStep("index", "done", "Snapshot reloaded");
        els.indexInfo.textContent = JSON.stringify(data, null, 2);
        addLog("Snapshot reloaded.", "success");
        return data;
      };

      const runQuery = async () => {
        const { queryUrl } = getConfig();
        if (!queryUrl) {
          throw new Error("Query URL is required.");
        }
        setStep("query", "working", "Running query...");
        const payload = {
          query_text: els.queryText.value.trim(),
          top_k: Number(els.topK.value) || 5,
        };
        const data = await apiFetch(queryUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        els.queryResults.textContent = JSON.stringify(data, null, 2);
        setStep("query", "done", `Results: ${data?.results?.length || 0}`);
        addLog("Query complete.", "success");
        return data;
      };

      const runAll = async () => {
        try {
          await uploadFile();
          await pollIngest();
          await fetchManifest();
          await reloadSnapshot();
          await runQuery();
        } catch (err) {
          addLog(err.message, "error");
          setStep("query", "error", err.message);
        }
      };

      els.saveConfig.addEventListener("click", saveConfig);
      els.resetConfig.addEventListener("click", clearConfig);
      els.uploadBtn.addEventListener("click", async () => {
        try {
          await uploadFile();
        } catch (err) {
          addLog(err.message, "error");
          setStep("upload", "error", err.message);
        }
      });
      els.pollBtn.addEventListener("click", async () => {
        try {
          await pollIngest();
        } catch (err) {
          addLog(err.message, "error");
          setStep("ingest", "error", err.message);
        }
      });
      els.runAllBtn.addEventListener("click", runAll);
      els.manifestBtn.addEventListener("click", async () => {
        try {
          await fetchManifest();
        } catch (err) {
          addLog(err.message, "error");
          setStep("manifest", "error", err.message);
        }
      });
      els.indexBtn.addEventListener("click", async () => {
        try {
          await triggerIndex();
        } catch (err) {
          addLog(err.message, "error");
          setStep("index", "error", err.message);
        }
      });
      els.indexStatusBtn.addEventListener("click", async () => {
        try {
          await indexStatus();
        } catch (err) {
          addLog(err.message, "error");
        }
      });
      els.reloadBtn.addEventListener("click", async () => {
        try {
          await reloadSnapshot();
        } catch (err) {
          addLog(err.message, "error");
        }
      });
      els.queryBtn.addEventListener("click", async () => {
        try {
          await runQuery();
        } catch (err) {
          addLog(err.message, "error");
          setStep("query", "error", err.message);
        }
      });
      if (els.storyRefresh) {
        els.storyRefresh.addEventListener("click", async () => {
          try {
            await loadVideoStory();
          } catch (err) {
            addLog(err.message, "error");
          }
        });
      }
      els.storyTabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          activateStoryTab(tab.dataset.storyTab);
        });
      });

      loadConfig();
    </script>
  </body>
</html>
